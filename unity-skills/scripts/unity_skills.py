#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Unity Skills Python Helper
# Auto-generated by UnitySkills

# CRITICAL: Fix Windows console encoding BEFORE any other imports or print statements
# This must be at the very top of the module to work correctly
import sys
if sys.platform == 'win32':
    import codecs
    if hasattr(sys.stdout, 'buffer'):
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'replace')
    if hasattr(sys.stderr, 'buffer'):
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'replace')

import requests
import time
import json
import os
from typing import Any, Dict, Optional

UNITY_URL = "http://localhost:8090"
DEFAULT_PORT = 8090

def get_registry_path():
    return os.path.join(os.path.expanduser("~"), ".unity_skills", "registry.json")

class UnitySkills:
    """
    Client for interacting with a specific Unity Editor instance.
    """
    def __init__(self, port: int = None, target: str = None, url: str = None):
        """
        Initialize client.
        Args:
            port: Connect to specific localhost port (e.g. 8091)
            target: Connect to instance by Name or ID (e.g. "MyGame" or "MyGame_A1B2") - auto-discovers port.
            url: Full URL override.
        """
        self.url = url
        
        if not self.url:
            if port:
                self.url = f"http://localhost:{port}"
            elif target:
                found_port = self._find_port_by_target(target)
                if found_port:
                    self.url = f"http://localhost:{found_port}"
                else:
                    raise ValueError(f"Could not find Unity instance matching '{target}' in registry.")
            else:
                self.url = f"http://localhost:{DEFAULT_PORT}"

    def _find_port_by_target(self, target: str) -> Optional[int]:
        reg_path = get_registry_path()
        if not os.path.exists(reg_path):
            return None
        try:
            with open(reg_path, 'r') as f:
                data = json.load(f)
                # target can be ID or Name
                # 1. Exact ID match
                for path, info in data.items():
                    if info.get('id') == target:
                        return info.get('port')
                # 2. Exact Name match (if unique?) - return first found
                for path, info in data.items():
                    if info.get('name') == target:
                        return info.get('port')
                return None
        except:
            return None

    def call(self, skill_name: str, verbose: bool = False, **kwargs) -> Dict[str, Any]:
        """
        Call a skill on this instance.
        
        Returns a normalized response with 'success' field and flattened result data.
        """
        try:
            # Combine verbose into kwargs for JSON body
            kwargs['verbose'] = verbose
            response = requests.post(f"{self.url}/skill/{skill_name}", json=kwargs, timeout=30)
            response.encoding = 'utf-8'  # 确保正确解码UTF-8

            try:
                data = response.json()
            except ValueError:
                return {'success': False, 'error': f"Invalid JSON response: {response.text}"}

            # 规范化响应格式：将 {"status": "success", "result": {...}} 转换为 {"success": True, ...}
            if data.get('status') == 'success':
                result = data.get('result', {})
                # 将result的内容提升到顶层，并添加success标志
                normalized = {'success': True}
                if isinstance(result, dict):
                    normalized.update(result)
                else:
                    normalized['result'] = result
                return normalized
            elif data.get('status') == 'error':
                return {
                    'success': False,
                    'error': data.get('error', 'Unknown error'),
                    'message': data.get('message', '')
                }
            else:
                return data

        except requests.exceptions.ConnectionError:
             return {
                'success': False,
                'error': f"Cannot connect to {self.url}. Unity instance may be down.",
                'suggestion': 'Unity may be recompiling scripts (Domain Reload). Wait 3-5 seconds and retry.',
                'hint': 'Check if server is running: Window > UnitySkills > Start Server'
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}

    # --- Proxies for common skills ---
    def create_cube(self, x=0, y=0, z=0, name="Cube"): return self.call("create_cube", x=x, y=y, z=z, name=name)
    def create_sphere(self, x=0, y=0, z=0, name="Sphere"): return self.call("create_sphere", x=x, y=y, z=z, name=name)
    def delete_object(self, name): return self.call("delete_object", objectName=name)


# Global Default Client
_default_client = UnitySkills()

# Auto-workflow configuration
_auto_workflow_enabled = True  # Enable auto-workflow
_current_workflow_active = False  # Is a workflow currently active?

# Skills that should trigger auto-workflow (modification operations)
_workflow_tracked_skills = {
    'gameobject_create', 'gameobject_delete', 'gameobject_rename',
    'gameobject_set_transform', 'gameobject_duplicate', 'gameobject_set_parent',
    'gameobject_set_active', 'gameobject_create_batch', 'gameobject_delete_batch',
    'gameobject_rename_batch', 'gameobject_set_transform_batch',
    'component_add', 'component_remove', 'component_set_property',
    'component_add_batch', 'component_remove_batch', 'component_set_property_batch',
    'material_create', 'material_assign', 'material_set_color', 'material_set_texture',
    'material_set_emission', 'material_set_float', 'material_set_shader',
    'material_create_batch', 'material_assign_batch', 'material_set_colors_batch',
    'light_create', 'light_set_properties', 'light_set_enabled',
    'prefab_create', 'prefab_instantiate', 'prefab_apply', 'prefab_unpack',
    'prefab_instantiate_batch',
    'ui_create_canvas', 'ui_create_panel', 'ui_create_button', 'ui_create_text',
    'ui_create_image', 'ui_create_inputfield', 'ui_create_slider', 'ui_create_toggle',
    'ui_create_batch', 'ui_set_text', 'ui_set_anchor', 'ui_set_rect',
    'script_create', 'script_delete', 'script_create_batch',
    'terrain_create', 'terrain_set_height', 'terrain_set_heights_batch', 'terrain_paint_texture',
    'asset_import', 'asset_delete', 'asset_move', 'asset_duplicate',
    'scene_create', 'scene_save',
}

def set_auto_workflow(enabled: bool):
    """Enable or disable auto-workflow recording."""
    global _auto_workflow_enabled
    _auto_workflow_enabled = enabled

def is_auto_workflow_enabled() -> bool:
    """Check if auto-workflow is enabled."""
    return _auto_workflow_enabled

def connect(port: int = None, target: str = None) -> UnitySkills:
    return UnitySkills(port=port, target=target)

def list_instances() -> list:
    """Return list of active Unity instances from registry."""
    reg_path = get_registry_path()
    if not os.path.exists(reg_path):
        return []
    try:
        with open(reg_path, 'r') as f:
            data = json.load(f)
            return list(data.values())
    except:
        return []

def call_skill(skill_name: str, **kwargs) -> Dict[str, Any]:
    """
    Call a Unity skill, supporting auto-workflow recording.

    If auto-workflow is enabled (default), it will automatically:
    1. Start a workflow task before a modification operation
    2. Execute the operation
    3. End the workflow task
    """
    global _current_workflow_active

    # Check if we should track this call
    should_track = (
        _auto_workflow_enabled and
        skill_name in _workflow_tracked_skills and
        not _current_workflow_active and
        not skill_name.startswith('workflow_')  # Avoid recursion
    )

    if should_track:
        # Start workflow
        _current_workflow_active = True
        _default_client.call(
            'workflow_task_start',
            tag=skill_name,
            description=f"Auto: {skill_name} - {str(kwargs)[:100]}"
        )

        # Execute actual operation
        result = _default_client.call(skill_name, **kwargs)

        # End workflow
        _default_client.call('workflow_task_end')
        _current_workflow_active = False

        return result
    else:
        return _default_client.call(skill_name, **kwargs)


class WorkflowContext:
    """
    Workflow context manager for batching multiple operations into a single workflow task.

    Usage:
        with WorkflowContext('Create Scene', 'Build player and environment'):
            call_skill('gameobject_create', name='Player')
            call_skill('component_add', name='Player', componentType='Rigidbody')
    """
    def __init__(self, tag: str, description: str = ''):
        self.tag = tag
        self.description = description

    def __enter__(self):
        global _current_workflow_active
        _current_workflow_active = True
        call_skill('workflow_task_start', tag=self.tag, description=self.description)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        global _current_workflow_active
        call_skill('workflow_task_end')
        _current_workflow_active = False
        return False  # Do not suppress exceptions

def workflow_context(tag: str, description: str = '') -> WorkflowContext:
    """Convenience function to create a WorkflowContext."""
    return WorkflowContext(tag, description)

def call_skill_with_retry(skill_name: str, max_retries: int = 3, retry_delay: float = 2.0, **kwargs) -> Dict[str, Any]:
    """Call a Unity skill with automatic retry logic for Domain Reload scenarios."""
    for attempt in range(max_retries):
        result = call_skill(skill_name, **kwargs)
        # 检查success字段而不是error字段
        if result.get('success') or ('error' not in result or 'Cannot connect' not in result.get('error', '')):
            return result
        if attempt < max_retries - 1:
            time.sleep(retry_delay)
    return result

def get_skills() -> Dict[str, Any]:
    """Get list of all available skills."""
    try:
        response = requests.get(f"{UNITY_URL}/skills", timeout=5)
        response.encoding = 'utf-8'
        return response.json()
    except Exception as e:
        return {"status": "error", "error": str(e)}

def health() -> bool:
    """Check if Unity server is running."""
    try:
        response = requests.get(f"{UNITY_URL}/health", timeout=2)
        response.encoding = 'utf-8'
        return response.json().get("status") == "ok"
    except:
        return False

# ============================================================
# Main CLI Entry Point
# ============================================================
def main():
    """Command-line interface for Unity Skills."""
    if len(sys.argv) < 2:
        print('用法: python unity_skills.py <skill_name> [param1=value1] [param2=value2] ...')
        print('示例: python unity_skills.py editor_get_selection')
        print('示例: python unity_skills.py gameobject_create name=MyCube primitiveType=Cube')
        sys.exit(1)

    if sys.argv[1] == "--list":
        print(json.dumps(get_skills(), ensure_ascii=False, indent=2))
        return
    elif sys.argv[1] == "--list-instances":
        print(json.dumps(list_instances(), ensure_ascii=False, indent=2))
        return

    skill_name = sys.argv[1]

    # Parse parameters
    params = {}
    for arg in sys.argv[2:]:
        if '=' in arg:
            key, value = arg.split('=', 1)
            # Try to parse as number or boolean
            if value.lower() == 'true':
                value = True
            elif value.lower() == 'false':
                value = False
            elif value.replace('.', '', 1).replace('-', '', 1).isdigit():
                try:
                    value = float(value) if '.' in value else int(value)
                except ValueError:
                    pass
            params[key] = value

    # Call the skill
    result = call_skill(skill_name, **params)

    # Pretty print the result
    print(json.dumps(result, ensure_ascii=False, indent=2))

if __name__ == '__main__':
    main()
