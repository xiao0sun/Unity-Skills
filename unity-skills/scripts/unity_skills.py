#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Unity Skills Python Helper
# Auto-generated by UnitySkills

# CRITICAL: Fix Windows console encoding BEFORE any other imports or print statements
# This must be at the very top of the module to work correctly
import sys
if sys.platform == 'win32':
    import codecs
    if hasattr(sys.stdout, 'buffer'):
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'replace')
    if hasattr(sys.stderr, 'buffer'):
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'replace')

import requests
import time
import json
import os
from typing import Any, Dict, List, Optional

__version__ = "1.5.0"

UNITY_URL = "http://localhost:8090"
DEFAULT_PORT = 8090
PORT_RANGE_START = 8090
PORT_RANGE_END = 8100

# Timeout constants (seconds)
DEFAULT_CALL_TIMEOUT = 30
HEALTH_TIMEOUT = 2
SCAN_TIMEOUT = 1

def get_registry_path():
    return os.path.join(os.path.expanduser("~"), ".unity_skills", "registry.json")


def _version_matches(actual_version: str, target: str) -> bool:
    """
    Version prefix matching with Unity 6 special format support.

    Unity 6 uses internal version like '6000.0.xxf1', so user input '6' or 'Unity 6'
    should match '6000.x.x'. Traditional versions like '2022.3.12f1' use direct prefix matching.

    Examples:
        _version_matches("6000.0.28f1", "6")       -> True
        _version_matches("6000.0.28f1", "Unity 6")  -> True
        _version_matches("6000.0.28f1", "6000")     -> True
        _version_matches("2022.3.12f1", "2022")     -> True
        _version_matches("2022.3.12f1", "2022.3")   -> True
        _version_matches("2022.3.12f1", "6")        -> False
    """
    if not actual_version or not target:
        return False

    # Strip "Unity" prefix and whitespace from target
    cleaned = target.strip()
    if cleaned.lower().startswith("unity"):
        cleaned = cleaned[5:].strip()

    if not cleaned:
        return False

    # Unity 6 special mapping: user says "6" -> match "6000."
    if cleaned == "6":
        return actual_version.startswith("6000.")

    # Direct prefix match for everything else (e.g. "6000", "2022", "2022.3")
    return actual_version.startswith(cleaned)


class UnitySkills:
    """
    Client for interacting with a specific Unity Editor instance.
    """
    def __init__(self, port: int = None, target: str = None, url: str = None, version: str = None, agent_id: str = None, timeout: int = None):
        """
        Initialize client.
        Args:
            port: Connect to specific localhost port (e.g. 8091)
            target: Connect to instance by Name or ID (e.g. "MyGame" or "MyGame_A1B2") - auto-discovers port.
            url: Full URL override.
            version: Connect to instance by Unity version (e.g. "6", "2022", "2022.3") - auto-discovers port.
            agent_id: Custom agent identifier (e.g. "MyScript", "ClaudeCode")
            timeout: Request timeout in seconds (default: 30)
        Priority: url > port > target > version > default port 8090
        """
        self.url = url
        self.agent_id = agent_id or "Python"
        self.timeout = timeout or DEFAULT_CALL_TIMEOUT
        # 连接复用：使用 Session 保持 TCP 连接
        self._session = requests.Session()
        self._session.headers.update({
            'X-Agent-Id': self.agent_id,
            'User-Agent': f'unity-skills-python/{__version__}',
        })

        if not self.url:
            if port:
                self.url = f"http://localhost:{port}"
            elif target:
                found_port = self._find_port_by_target(target)
                if found_port:
                    self.url = f"http://localhost:{found_port}"
                else:
                    raise ValueError(f"Could not find Unity instance matching '{target}' in registry.")
            elif version:
                found_port = self._find_port_by_version(version)
                if found_port:
                    self.url = f"http://localhost:{found_port}"
                else:
                    raise ValueError(f"Could not find Unity instance matching version '{version}'.")
            else:
                # Auto-discover: scan 8090-8100 for first responding instance
                found_port = self._find_first_available()
                self.url = f"http://localhost:{found_port}"

    def _find_first_available(self) -> int:
        """扫描 8090-8100，返回第一个响应的端口"""
        for port in range(PORT_RANGE_START, PORT_RANGE_END + 1):
            try:
                resp = requests.get(f"http://localhost:{port}/health", timeout=SCAN_TIMEOUT)
                if resp.status_code == 200:
                    return port
            except (requests.exceptions.RequestException, ValueError):
                continue
        return DEFAULT_PORT  # fallback 到 8090

    def _find_port_by_target(self, target: str) -> Optional[int]:
        reg_path = get_registry_path()
        if not os.path.exists(reg_path):
            return None
        try:
            with open(reg_path, 'r') as f:
                data = json.load(f)
                # target can be ID or Name
                # 1. Exact ID match
                for path, info in data.items():
                    if info.get('id') == target:
                        return info.get('port')
                # 2. Exact Name match (if unique?) - return first found
                for path, info in data.items():
                    if info.get('name') == target:
                        return info.get('port')
                return None
        except (IOError, json.JSONDecodeError, KeyError):
            return None

    def _find_port_by_version(self, version: str) -> Optional[int]:
        """
        Find a Unity instance port by version string.

        Three-stage search strategy (decreasing efficiency):
        1. Check registry - read unityVersion field from registry.json (no HTTP overhead)
        2. Probe health - when registry has no version info (old server), call /health on registered ports
        3. Scan ports - when registry is empty/missing, scan ports 8090-8100
        """
        reg_path = get_registry_path()
        registry_data = None

        # Load registry if available
        if os.path.exists(reg_path):
            try:
                with open(reg_path, 'r') as f:
                    registry_data = json.load(f)
            except (IOError, json.JSONDecodeError):
                registry_data = None

        # Stage 1: Check registry unityVersion field
        if registry_data:
            for path, info in registry_data.items():
                reg_version = info.get('unityVersion')
                if reg_version and _version_matches(reg_version, version):
                    port = info.get('port')
                    if port:
                        return port

            # Stage 2: Probe /health for registered ports without version info
            ports_without_version = []
            for path, info in registry_data.items():
                if not info.get('unityVersion') and info.get('port'):
                    ports_without_version.append(info['port'])

            for port in ports_without_version:
                try:
                    resp = requests.get(f"http://localhost:{port}/health", timeout=HEALTH_TIMEOUT)
                    if resp.status_code == 200:
                        health_data = resp.json()
                        health_version = health_data.get('unityVersion')
                        if health_version and _version_matches(health_version, version):
                            return port
                except (requests.exceptions.RequestException, ValueError):
                    continue

        # Stage 3: Scan port range (fallback when registry is empty/missing)
        if not registry_data:
            for port in range(PORT_RANGE_START, PORT_RANGE_END + 1):
                try:
                    resp = requests.get(f"http://localhost:{port}/health", timeout=SCAN_TIMEOUT)
                    if resp.status_code == 200:
                        health_data = resp.json()
                        health_version = health_data.get('unityVersion')
                        if health_version and _version_matches(health_version, version):
                            return port
                except (requests.exceptions.RequestException, ValueError):
                    continue

        return None

    def call(self, skill_name: str, verbose: bool = False, _retries: int = 2, _retry_delay: float = 1.5, **kwargs) -> Dict[str, Any]:
        """
        Call a skill on this instance with automatic retry on connection errors.

        Args:
            skill_name: Name of the skill to call
            verbose: Whether to return verbose output
            _retries: Number of retries on connection error (default 2)
            _retry_delay: Delay between retries in seconds (default 1.5)

        Returns a normalized response with 'success' field and flattened result data.
        """
        last_error = None
        for attempt in range(_retries + 1):
            try:
                # Combine verbose into kwargs for JSON body
                kwargs['verbose'] = verbose
                # 使用 ensure_ascii=False 保留原始中文字符，避免转义为 \uXXXX
                json_data = json.dumps(kwargs, ensure_ascii=False)
                response = self._session.post(
                    f"{self.url}/skill/{skill_name}",
                    data=json_data.encode('utf-8'),
                    headers={'Content-Type': 'application/json; charset=utf-8'},
                    timeout=self.timeout
                )
                response.encoding = 'utf-8'  # 确保正确解码UTF-8

                try:
                    data = response.json()
                except ValueError:
                    return {'success': False, 'error': f"Invalid JSON response: {response.text}"}

                # 规范化响应格式：将 {"status": "success", "result": {...}} 转换为 {"success": True, ...}
                if data.get('status') == 'success':
                    result = data.get('result', {})
                    # 将result的内容提升到顶层，并添加success标志
                    normalized = {'success': True}
                    if isinstance(result, dict):
                        normalized.update(result)
                    else:
                        normalized['result'] = result
                    return normalized
                elif data.get('status') == 'error':
                    return {
                        'success': False,
                        'error': data.get('error', 'Unknown error'),
                        'message': data.get('message', '')
                    }
                else:
                    return data

            except requests.exceptions.ConnectionError as e:
                last_error = e
                if attempt < _retries:
                    time.sleep(_retry_delay)
                    continue
                return {
                    'success': False,
                    'error': f"Cannot connect to {self.url}. Unity instance may be down.",
                    'suggestion': 'Unity may be recompiling scripts (Domain Reload). Wait 3-5 seconds and retry.',
                    'hint': 'Check if server is running: Window > UnitySkills > Start Server'
                }
            except Exception as e:
                return {'success': False, 'error': str(e)}

    # --- Proxies for common skills ---
    def create_cube(self, x=0, y=0, z=0, name="Cube"): return self.call("create_cube", x=x, y=y, z=z, name=name)
    def create_sphere(self, x=0, y=0, z=0, name="Sphere"): return self.call("create_sphere", x=x, y=y, z=z, name=name)
    def delete_object(self, name): return self.call("delete_object", objectName=name)


# Global Default Client (lazy initialization)
_default_client = None

def _get_default_client():
    """延迟初始化，首次调用时自动发现实例"""
    global _default_client
    if _default_client is None:
        _default_client = UnitySkills()
    return _default_client

# Auto-workflow configuration
_auto_workflow_enabled = True  # Enable auto-workflow
_current_workflow_active = False  # Is a workflow currently active?

# Skills that should trigger auto-workflow (modification operations)
_workflow_tracked_skills = {
    'gameobject_create', 'gameobject_delete', 'gameobject_rename',
    'gameobject_set_transform', 'gameobject_duplicate', 'gameobject_set_parent',
    'gameobject_set_active', 'gameobject_create_batch', 'gameobject_delete_batch',
    'gameobject_rename_batch', 'gameobject_set_transform_batch',
    'component_add', 'component_remove', 'component_set_property',
    'component_add_batch', 'component_remove_batch', 'component_set_property_batch',
    'material_create', 'material_assign', 'material_set_color', 'material_set_texture',
    'material_set_emission', 'material_set_float', 'material_set_shader',
    'material_create_batch', 'material_assign_batch', 'material_set_colors_batch',
    'light_create', 'light_set_properties', 'light_set_enabled',
    'prefab_create', 'prefab_instantiate', 'prefab_apply', 'prefab_unpack',
    'prefab_instantiate_batch',
    'ui_create_canvas', 'ui_create_panel', 'ui_create_button', 'ui_create_text',
    'ui_create_image', 'ui_create_inputfield', 'ui_create_slider', 'ui_create_toggle',
    'ui_create_batch', 'ui_set_text', 'ui_set_anchor', 'ui_set_rect',
    'script_create', 'script_delete', 'script_create_batch',
    'terrain_create', 'terrain_set_height', 'terrain_set_heights_batch', 'terrain_paint_texture',
    'asset_import', 'asset_delete', 'asset_move', 'asset_duplicate',
    'scene_create', 'scene_save',
}

def set_auto_workflow(enabled: bool):
    """Enable or disable auto-workflow recording."""
    global _auto_workflow_enabled
    _auto_workflow_enabled = enabled

def is_auto_workflow_enabled() -> bool:
    """Check if auto-workflow is enabled."""
    return _auto_workflow_enabled

def connect(port: int = None, target: str = None, version: str = None) -> UnitySkills:
    """
    Create a new UnitySkills client.
    Args:
        port: Connect to specific localhost port (e.g. 8091)
        target: Connect to instance by Name or ID
        version: Connect to instance by Unity version (e.g. "6", "2022", "2022.3")
    """
    return UnitySkills(port=port, target=target, version=version)

def set_unity_version(version: str):
    """
    Set target Unity version and reconfigure the default client.

    This is the primary way for AI agents to route to a specific Unity version
    when multiple instances are running.

    Args:
        version: Unity version string, e.g. "6", "Unity 6", "2022", "2022.3"

    Example:
        import unity_skills
        unity_skills.set_unity_version("6")       # Switch to Unity 6
        unity_skills.call_skill("gameobject_create", name="Cube")  # Auto-routes
    """
    global _default_client
    _default_client = UnitySkills(version=version)

def list_instances() -> list:
    """Return list of active Unity instances from registry."""
    reg_path = get_registry_path()
    if not os.path.exists(reg_path):
        return []
    try:
        with open(reg_path, 'r') as f:
            data = json.load(f)
            return list(data.values())
    except (IOError, json.JSONDecodeError):
        return []

def call_skill(skill_name: str, **kwargs) -> Dict[str, Any]:
    """
    Call a Unity skill, supporting auto-workflow recording.

    If auto-workflow is enabled (default), it will automatically:
    1. Start a workflow task before a modification operation
    2. Execute the operation
    3. End the workflow task
    """
    global _current_workflow_active

    # Check if we should track this call
    should_track = (
        _auto_workflow_enabled and
        skill_name in _workflow_tracked_skills and
        not _current_workflow_active and
        not skill_name.startswith('workflow_')  # Avoid recursion
    )

    if should_track:
        # Start workflow
        _current_workflow_active = True
        try:
            _get_default_client().call(
                'workflow_task_start',
                tag=skill_name,
                description=f"Auto: {skill_name} - {str(kwargs)[:100]}"
            )

            # Execute actual operation
            result = _get_default_client().call(skill_name, **kwargs)

            # End workflow
            _get_default_client().call('workflow_task_end')
            return result
        finally:
            _current_workflow_active = False
    else:
        return _get_default_client().call(skill_name, **kwargs)


class WorkflowContext:
    """
    Workflow context manager for batching multiple operations into a single workflow task.

    Usage:
        with WorkflowContext('Create Scene', 'Build player and environment'):
            call_skill('gameobject_create', name='Player')
            call_skill('component_add', name='Player', componentType='Rigidbody')
    """
    def __init__(self, tag: str, description: str = ''):
        self.tag = tag
        self.description = description

    def __enter__(self):
        global _current_workflow_active
        _current_workflow_active = True
        call_skill('workflow_task_start', tag=self.tag, description=self.description)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        global _current_workflow_active
        try:
            call_skill('workflow_task_end')
        finally:
            _current_workflow_active = False
        return False  # Do not suppress exceptions

def workflow_context(tag: str, description: str = '') -> WorkflowContext:
    """Convenience function to create a WorkflowContext."""
    return WorkflowContext(tag, description)

def call_skill_with_retry(skill_name: str, max_retries: int = 3, retry_delay: float = 2.0, **kwargs) -> Dict[str, Any]:
    """Call a Unity skill with automatic retry logic for Domain Reload scenarios."""
    for attempt in range(max_retries):
        result = call_skill(skill_name, **kwargs)

        is_connection_error = (
            not result.get('success')
            and 'Cannot connect' in result.get('error', '')
        )
        if not is_connection_error:
            return result

        if attempt < max_retries - 1:
            time.sleep(retry_delay)
    return result

def get_skills() -> Dict[str, Any]:
    """Get list of all available skills from the current default client."""
    try:
        response = requests.get(f"{_get_default_client().url}/skills", timeout=DEFAULT_CALL_TIMEOUT)
        response.encoding = 'utf-8'
        return response.json()
    except Exception as e:
        return {"status": "error", "error": str(e)}

def health() -> bool:
    """Check if the current default Unity server is running."""
    try:
        response = requests.get(f"{_get_default_client().url}/health", timeout=HEALTH_TIMEOUT)
        response.encoding = 'utf-8'
        return response.json().get("status") == "ok"
    except (requests.exceptions.RequestException, ValueError):
        return False

# ============================================================
# Main CLI Entry Point
# ============================================================
def main():
    """Command-line interface for Unity Skills."""
    import argparse

    parser = argparse.ArgumentParser(
        description='Unity Skills Python CLI',
        usage='python unity_skills.py [options] <skill_name> [param1=value1] ...'
    )
    parser.add_argument('--list', action='store_true', help='List all available skills')
    parser.add_argument('--list-instances', action='store_true', help='List active Unity instances')
    parser.add_argument('--port', type=int, default=None, help='Connect to specific port')
    parser.add_argument('--version', type=str, default=None, dest='unity_version',
                        help='Connect to Unity instance by version (e.g. "6", "2022", "2022.3")')
    parser.add_argument('skill_name', nargs='?', help='Skill name to execute')
    parser.add_argument('params', nargs='*', help='Skill parameters as key=value pairs')

    args = parser.parse_args()

    # Configure client based on CLI args
    if args.port or args.unity_version:
        global _default_client
        _default_client = UnitySkills(port=args.port, version=args.unity_version)

    if args.list:
        print(json.dumps(get_skills(), ensure_ascii=False, indent=2))
        return
    elif args.list_instances:
        print(json.dumps(list_instances(), ensure_ascii=False, indent=2))
        return

    if not args.skill_name:
        parser.print_help()
        sys.exit(1)

    # Parse parameters
    params = {}
    for arg in args.params:
        if '=' in arg:
            key, value = arg.split('=', 1)
            # Try to parse as number or boolean
            if value.lower() == 'true':
                value = True
            elif value.lower() == 'false':
                value = False
            elif value.replace('.', '', 1).replace('-', '', 1).isdigit():
                try:
                    value = float(value) if '.' in value else int(value)
                except ValueError:
                    pass
            params[key] = value

    # Call the skill
    result = call_skill(args.skill_name, **params)

    # Pretty print the result
    print(json.dumps(result, ensure_ascii=False, indent=2))

if __name__ == '__main__':
    main()
