#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Unity Skills Python Helper
# Auto-generated by UnitySkills
import requests
import time
import sys
import json
import io
import os
from typing import Any, Dict, Optional

# Fix Windows console encoding for Chinese characters
if sys.platform == 'win32':
    if hasattr(sys.stdout, 'buffer'):
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    if hasattr(sys.stderr, 'buffer'):
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

UNITY_URL = "http://localhost:8090"
DEFAULT_PORT = 8090

def get_registry_path():
    return os.path.join(os.path.expanduser("~"), ".unity_skills", "registry.json")

class UnitySkills:
    """
    Client for interacting with a specific Unity Editor instance.
    """
    def __init__(self, port: int = None, target: str = None, url: str = None):
        """
        Initialize client.
        Args:
            port: Connect to specific localhost port (e.g. 8091)
            target: Connect to instance by Name or ID (e.g. "MyGame" or "MyGame_A1B2") - auto-discovers port.
            url: Full URL override.
        """
        self.url = url
        
        if not self.url:
            if port:
                self.url = f"http://localhost:{port}"
            elif target:
                found_port = self._find_port_by_target(target)
                if found_port:
                    self.url = f"http://localhost:{found_port}"
                else:
                    raise ValueError(f"Could not find Unity instance matching '{target}' in registry.")
            else:
                self.url = f"http://localhost:{DEFAULT_PORT}"

    def _find_port_by_target(self, target: str) -> Optional[int]:
        reg_path = get_registry_path()
        if not os.path.exists(reg_path):
            return None
        try:
            with open(reg_path, 'r') as f:
                data = json.load(f)
                # target can be ID or Name
                # 1. Exact ID match
                for path, info in data.items():
                    if info.get('id') == target:
                        return info.get('port')
                # 2. Exact Name match (if unique?) - return first found
                for path, info in data.items():
                    if info.get('name') == target:
                        return info.get('port')
                return None
        except:
            return None

    def call(self, skill_name: str, verbose: bool = False, **kwargs) -> Dict[str, Any]:
        """
        Call a skill on this instance.
        
        Returns a normalized response with 'success' field and flattened result data.
        """
        try:
            # Combine verbose into kwargs for JSON body
            kwargs['verbose'] = verbose
            response = requests.post(f"{self.url}/skill/{skill_name}", json=kwargs, timeout=30)
            response.encoding = 'utf-8'  # 确保正确解码UTF-8

            try:
                data = response.json()
            except ValueError:
                return {'success': False, 'error': f"Invalid JSON response: {response.text}"}

            # 规范化响应格式：将 {"status": "success", "result": {...}} 转换为 {"success": True, ...}
            if data.get('status') == 'success':
                result = data.get('result', {})
                # 将result的内容提升到顶层，并添加success标志
                normalized = {'success': True}
                if isinstance(result, dict):
                    normalized.update(result)
                else:
                    normalized['result'] = result
                return normalized
            elif data.get('status') == 'error':
                return {
                    'success': False,
                    'error': data.get('error', 'Unknown error'),
                    'message': data.get('message', '')
                }
            else:
                return data

        except requests.exceptions.ConnectionError:
             return {
                'success': False,
                'error': f"Cannot connect to {self.url}. Unity instance may be down.",
                'suggestion': 'Unity may be recompiling scripts (Domain Reload). Wait 3-5 seconds and retry.',
                'hint': 'Check if server is running: Window > UnitySkills > Start Server'
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}

    # --- Proxies for common skills ---
    def create_cube(self, x=0, y=0, z=0, name="Cube"): return self.call("create_cube", x=x, y=y, z=z, name=name)
    def create_sphere(self, x=0, y=0, z=0, name="Sphere"): return self.call("create_sphere", x=x, y=y, z=z, name=name)
    def delete_object(self, name): return self.call("delete_object", objectName=name)


# Global Default Client
_default_client = UnitySkills()

def connect(port: int = None, target: str = None) -> UnitySkills:
    return UnitySkills(port=port, target=target)

def list_instances() -> list:
    """Return list of active Unity instances from registry."""
    reg_path = get_registry_path()
    if not os.path.exists(reg_path):
        return []
    try:
        with open(reg_path, 'r') as f:
            data = json.load(f)
            return list(data.values())
    except:
        return []

def call_skill(skill_name: str, **kwargs) -> Dict[str, Any]:
    return _default_client.call(skill_name, **kwargs)

def call_skill_with_retry(skill_name: str, max_retries: int = 3, retry_delay: float = 2.0, **kwargs) -> Dict[str, Any]:
    """Call a Unity skill with automatic retry logic for Domain Reload scenarios."""
    for attempt in range(max_retries):
        result = call_skill(skill_name, **kwargs)
        # 检查success字段而不是error字段
        if result.get('success') or ('error' not in result or 'Cannot connect' not in result.get('error', '')):
            return result
        if attempt < max_retries - 1:
            time.sleep(retry_delay)
    return result

def get_skills() -> Dict[str, Any]:
    """Get list of all available skills."""
    try:
        response = requests.get(f"{UNITY_URL}/skills", timeout=5)
        response.encoding = 'utf-8'
        return response.json()
    except Exception as e:
        return {"status": "error", "error": str(e)}

def health() -> bool:
    """Check if Unity server is running."""
    try:
        response = requests.get(f"{UNITY_URL}/health", timeout=2)
        response.encoding = 'utf-8'
        return response.json().get("status") == "ok"
    except:
        return False

# ============================================================
# Main CLI Entry Point
# ============================================================
def main():
    """Command-line interface for Unity Skills."""
    if len(sys.argv) < 2:
        print('用法: python unity_skills.py <skill_name> [param1=value1] [param2=value2] ...')
        print('示例: python unity_skills.py editor_get_selection')
        print('示例: python unity_skills.py gameobject_create name=MyCube primitiveType=Cube')
        sys.exit(1)

    if sys.argv[1] == "--list":
        print(json.dumps(get_skills(), ensure_ascii=False, indent=2))
        return
    elif sys.argv[1] == "--list-instances":
        print(json.dumps(list_instances(), ensure_ascii=False, indent=2))
        return

    skill_name = sys.argv[1]

    # Parse parameters
    params = {}
    for arg in sys.argv[2:]:
        if '=' in arg:
            key, value = arg.split('=', 1)
            # Try to parse as number or boolean
            if value.lower() == 'true':
                value = True
            elif value.lower() == 'false':
                value = False
            elif value.replace('.', '', 1).replace('-', '', 1).isdigit():
                try:
                    value = float(value) if '.' in value else int(value)
                except ValueError:
                    pass
            params[key] = value

    # Call the skill
    result = call_skill(skill_name, **params)

    # Pretty print the result
    print(json.dumps(result, ensure_ascii=False, indent=2))

if __name__ == '__main__':
    main()
